{
  "root": "/Users/prabhatsingh/param-tatva-sim",
  "generated_at_utc": "2025-09-24T01:39:12.915358Z",
  "files": [
    {
      "path": "pt-sim/pt_sim/__init__.py",
      "size": 264,
      "content": "__version__ = \"0.2.0\"\n\n# Explicit re-exports so Ruff treats them as used\nfrom . import physics as physics  # re-export\nfrom . import forces as forces    # re-export\nfrom . import io as io            # re-export\n\n__all__ = [\"physics\", \"forces\", \"io\", \"__version__\"]",
      "sha256": "d0023bf3d9d0c051645ecccba7c73a59fbfcef7e7e04d2d8f0c0a631a184b9ef"
    },
    {
      "path": "pt-sim/pt_sim/demo_forces.py",
      "size": 2825,
      "content": "from pathlib import Path\nimport json\n\nimport numpy as np\nimport matplotlib.pyplot as plt\n\nfrom .forces.gauge import Particle, UniformField  # adjust if your paths differ\nfrom .forces.em import integrate_motion           # legacy NR integrator\nfrom .forces.potentials import (                  # adjust import path if needed\n    coulomb_potential,\n    yukawa_potential,\n    string_potential,\n    flux_tube_map,\n)\n\n\ndef demo_lorentz(outdir: str) -> str:\n    out = Path(outdir)\n    out.mkdir(parents=True, exist_ok=True)\n\n    e = Particle(q=-1.0, m=0.511)\n    field = UniformField(E_vec=(0.0, 0.0, 0.0), B_vec=(0.0, 0.0, 1.0))\n    xs, vs = integrate_motion(e, field, (0.0, 0.0, 0.0), (0.7, 0.0, 0.0), dt=0.05, steps=1200)\n\n    plt.figure()\n    plt.plot(xs[:, 0], xs[:, 1], lw=1.2)\n    plt.axis(\"equal\")\n    plt.xlabel(\"x\")\n    plt.ylabel(\"y\")\n    plt.title(\"Electron in Uniform B (toy NR integrator)\")\n\n    png_path = out / \"force_lorentz_spiral.png\"\n    plt.savefig(png_path, dpi=160, bbox_inches=\"tight\")\n    plt.close()\n    return str(png_path)\n\n\ndef demo_potentials(outdir: str) -> str:\n    out = Path(outdir)\n    out.mkdir(parents=True, exist_ok=True)\n\n    r = np.linspace(0.05, 10.0, 1000)\n    Vc = coulomb_potential(r, 1.0)\n    Vy = yukawa_potential(r, 1.0, 0.7)\n    Vs = string_potential(r, 0.2, 0.0)\n\n    plt.figure()\n    plt.plot(r, Vc, label=\"Coulomb 1/r\")\n    plt.plot(r, Vy, label=\"Yukawa e^{-mr}/r\")\n    plt.plot(r, Vs, label=\"String Îºr\")\n    plt.ylim(0, 10)\n    plt.legend()\n    plt.xlabel(\"r\")\n    plt.ylabel(\"V(r)\")\n    plt.title(\"Force Potentials (toy)\")\n\n    png_path = out / \"force_potentials.png\"\n    plt.savefig(png_path, dpi=160, bbox_inches=\"tight\")\n    plt.close()\n    return str(png_path)\n\n\ndef demo_flux_tube(outdir: str) -> str:\n    out = Path(outdir)\n    out.mkdir(parents=True, exist_ok=True)\n\n    X, Y, E = flux_tube_map(n=160, sep=10.0, width=1.5)\n\n    plt.figure()\n    plt.imshow(\n        E,\n        origin=\"lower\",\n        extent=[X.min(), X.max(), Y.min(), Y.max()],\n        interpolation=\"bilinear\",\n    )\n    plt.colorbar(label=\"Normalized energy density\")\n    plt.xlabel(\"x\")\n    plt.ylabel(\"y\")\n    plt.title(\"Toy Color Flux Tube (QCD-like)\")\n\n    png_path = out / \"force_flux_tube.png\"\n    plt.savefig(png_path, dpi=160, bbox_inches=\"tight\")\n    plt.close()\n    return str(png_path)\n\n\ndef run_all(outdir: str) -> str:\n    out = Path(outdir)\n    out.mkdir(parents=True, exist_ok=True)\n\n    results = {\n        \"spiral_png\": demo_lorentz(out),\n        \"potentials_png\": demo_potentials(out),\n        \"flux_tube_png\": demo_flux_tube(out),\n    }\n\n    with open(out / \"demo_forces_summary.json\", \"w\") as f:\n        json.dump(results, f, indent=2)\n\n    return str(out)\n\n\nif __name__ == \"__main__\":\n    import sys\n\n    target = sys.argv[1] if len(sys.argv) > 1 else \"../out\"\n    run_all(target)\n",
      "sha256": "befc4883c7639fe2c7f14a9ac6bd954f8d5eb02361184a1994556c0305ed84ba"
    },
    {
      "path": "pt-sim/pt_sim/demo_run.py",
      "size": 2698,
      "content": "import json\nfrom pathlib import Path\n\nimport numpy as np\nimport matplotlib.pyplot as plt\n\nfrom .physics import simplified as ps\nfrom .physics import accurate as pa\nfrom .paramsutra import load  # adjust if your config loader lives elsewhere\n\n\ndef run(config_path: str, outdir: str) -> str:\n    cfg = load(config_path)\n    out = Path(outdir)\n    out.mkdir(parents=True, exist_ok=True)\n\n    mode = getattr(cfg, \"mode\", \"simplified\")\n    E = 10.0\n    n = cfg.ecal_geom.n_cells\n    depth = np.linspace(0.0, cfg.shower.depth_X0, n)\n\n    if mode == \"simplified\":\n        longE = ps.longitudinal_profile(depth, cfg.shower.alpha, cfg.shower.beta, E)\n        lat = ps.lateral_template(n, cfg.shower.lateral_sigma_cm, cfg.ecal_geom.cell_size_cm)\n        e_true = np.zeros((n, n))\n        for e in longE:\n            e_true += e * lat\n        meas = np.clip(\n            e_true * cfg.ecal_geom.sampling_fraction\n            + np.random.normal(0.0, cfg.ecal_geom.noise_sigma, size=(n, n)),\n            0.0,\n            None,\n        )\n        tag = \"simplified\"\n    else:\n        longE = pa.longitudinal_em(depth, E, X0_cm=cfg.material.X0_cm, Ec_MeV=cfg.material.Ec_MeV)\n        lat = pa.lateral_em(n, cfg.ecal_geom.cell_size_cm, cfg.material.RM_cm)\n        e_true = np.zeros((n, n))\n        for e in longE:\n            e_true += e * lat\n        rng = np.random.default_rng(12345)\n        meas = pa.digitize_energy(\n            e_true,\n            cfg.material.sampling_fraction,\n            cfg.material.light_yield_pe_per_GeV,\n            cfg.material.electronics_noise_sigma,\n            rng=rng,\n        )\n        tag = \"accurate\"\n\n    # Plots\n    plt.figure()\n    plt.imshow(meas, origin=\"lower\", interpolation=\"nearest\")\n    plt.colorbar(label=\"Energy (GeV)\")\n    plt.title(f\"ECAL Energy Image (electron, {tag})\")\n    plt.savefig(out / f\"ecal_image_{tag}.png\", dpi=160, bbox_inches=\"tight\")\n    plt.close()\n\n    plt.figure()\n    plt.plot(depth, longE)\n    plt.xlabel(\"Depth (X0 units)\")\n    plt.ylabel(\"Energy per layer (GeV)\")\n    plt.title(f\"Longitudinal Profile (electron, {tag})\")\n    plt.savefig(out / f\"longitudinal_profile_{tag}.png\", dpi=160, bbox_inches=\"tight\")\n    plt.close()\n\n    with open(out / f\"summary_{tag}.json\", \"w\") as f:\n        json.dump(\n            {\n                \"mode\": mode,\n                \"electron_energy_GeV\": E,\n                \"sum_measured_GeV\": float(meas.sum()),\n                \"n_cells\": int(n * n),\n                \"config_used\": str(Path(config_path).resolve()),\n            },\n            f,\n            indent=2,\n        )\n\n    return str(out)\n\n\nif __name__ == \"__main__\":\n    import sys\n\n    run(sys.argv[1], sys.argv[2] if len(sys.argv) > 2 else \"../out\")\n",
      "sha256": "343f53f8c599379e4f44022150a1a728f5da0afdaf9f6f96b16463440ca03c1c"
    },
    {
      "path": "pt-sim/pt_sim/fastcore.py",
      "size": 713,
      "content": "\"\"\"\nFast-path wrappers. Prefer Rust (pt_core_py) if available, else Python fallback.\n\"\"\"\n\ntry:\n    import pt_core_py as _rc  # type: ignore[import-not-found]\n    HAVE_RUST = True\nexcept Exception:\n    _rc = None\n    HAVE_RUST = False\n\n\ndef kk_winding_mass2(m1, m2, w1, w2, r1, r2, alpha_prime):\n    if HAVE_RUST:\n        return float(\n            _rc.kk_winding_mass2_py(\n                int(m1),\n                int(m2),\n                int(w1),\n                int(w2),\n                float(r1),\n                float(r2),\n                float(alpha_prime),\n            )\n        )\n    # Python fallback\n    return (m1 / r1) ** 2 + (m2 / r2) ** 2 + (w1 * r1 / alpha_prime) ** 2 + (w2 * r2 / alpha_prime) ** 2\n",
      "sha256": "173a18a0fd01658ba0a4c55522e00090124427a2cc0134ece543b1c8aa7a57af"
    },
    {
      "path": "pt-sim/pt_sim/forces/analytic.py",
      "size": 259,
      "content": "def helix_radius(v_perp, q_over_m, B_mag):\n    \"\"\"r = v_perp / omega,  omega = |q|B/m = |q_over_m|*B.\"\"\"\n    omega = abs(q_over_m) * abs(B_mag)\n    return abs(v_perp) / max(omega, 1e-16)\n\n\ndef cyclotron_frequency(q_over_m, B_mag):\n    return q_over_m * B_mag\n",
      "sha256": "fcbe659881c7079ca99f2bd8694418727426f4b86bcbc26adfe1f2273795eb68"
    },
    {
      "path": "pt-sim/pt_sim/forces/boris.py",
      "size": 1799,
      "content": "import numpy as np\nfrom .gauge import Particle  # noqa: F401  (used in type hints)\n\n\ndef boris_step(q_over_m, dt, v, E, B, relativistic=False, c=1.0):\n    \"\"\"\n    Single Boris push.\n    If relativistic=True, uses gamma from v at the beginning of the step.\n    Units: c can be 1.0 (natural units). Keep speeds well below c if non-relativistic.\n    \"\"\"\n    v = np.asarray(v, float)\n    E = np.asarray(E, float)\n    B = np.asarray(B, float)\n\n    if relativistic:\n        v2 = float(np.dot(v, v))\n        gamma = 1.0 / np.sqrt(max(1.0 - v2 / (c * c), 1e-12))\n    else:\n        gamma = 1.0\n\n    # Half electric kick\n    v_minus = v + (q_over_m * E) * (dt * 0.5) / gamma\n\n    # Magnetic rotation\n    t = q_over_m * B * (dt * 0.5) / gamma\n    t2 = float(np.dot(t, t))\n    v_prime = v_minus + np.cross(v_minus, t)\n    s = 2.0 * t / (1.0 + t2)\n    v_plus = v_minus + np.cross(v_prime, s)\n\n    # Half electric kick\n    v_new = v_plus + (q_over_m * E) * (dt * 0.5) / gamma\n    return v_new\n\n\ndef integrate_motion_boris(\n    p: Particle,\n    E_func,\n    B_func,\n    x0,\n    v0,\n    dt,\n    steps,\n    relativistic=False,\n    c=1.0,\n):\n    \"\"\"\n    Integrate trajectory with Boris pusher. E_func(t, x)->E, B_func(t, x)->B.\n    Returns arrays xs, vs (shape [steps, 3]).\n    \"\"\"\n    x = np.array(x0, float)\n    v = np.array(v0, float)\n    xs = np.zeros((steps, 3))\n    vs = np.zeros((steps, 3))\n\n    q_over_m = p.q / max(p.m, 1e-12)\n    t = 0.0\n\n    for i in range(steps):\n        E = np.asarray(E_func(t, x), float)\n        B = np.asarray(B_func(t, x), float)\n\n        # Boris velocity update\n        v = boris_step(q_over_m, dt, v, E, B, relativistic=relativistic, c=c)\n\n        # Position update (leapfrog consistent)\n        x = x + v * dt\n        xs[i] = x\n        vs[i] = v\n        t += dt\n\n    return xs, vs\n",
      "sha256": "367cd1587878f55017cfca7ad756f609b7cd55604763fef7bfbf307e79f7a1ea"
    },
    {
      "path": "pt-sim/pt_sim/forces/em.py",
      "size": 966,
      "content": "import numpy as np\nfrom .gauge import Field, lorentz_force\n\n\nclass UniformField(Field):\n    def __init__(self, E_vec=(0, 0, 0), B_vec=(0, 0, 1)):\n        self._E = np.array(E_vec, float)\n        self._B = np.array(B_vec, float)\n\n    def E(self, t, x):\n        return self._E\n\n    def B(self, t, x):\n        return self._B\n\n\ndef integrate_motion(particle, field, x0, v0, dt, steps):\n    x = np.array(x0, float)\n    v = np.array(v0, float)\n    xs = np.zeros((steps, 3))\n    vs = np.zeros((steps, 3))\n\n    for i in range(steps):\n        E = field.E(i * dt, x)\n        B = field.B(i * dt, x)\n        a = lorentz_force(particle, v, E, B) / max(particle.m, 1e-9)\n\n        v_half = v + 0.5 * dt * a\n        x = x + dt * v_half\n\n        E2 = field.E((i + 1) * dt, x)\n        B2 = field.B((i + 1) * dt, x)\n        a2 = lorentz_force(particle, v_half, E2, B2) / max(particle.m, 1e-9)\n\n        v = v_half + 0.5 * dt * a2\n\n        xs[i] = x\n        vs[i] = v\n\n    return xs, vs\n",
      "sha256": "d95a4fd9b6063a8271618a231da387ab9923be77b97f461eb575625309c71268"
    },
    {
      "path": "pt-sim/pt_sim/forces/gauge.py",
      "size": 250,
      "content": "from dataclasses import dataclass\nimport numpy as np\n@dataclass\nclass Particle: q: float; m: float\nclass Field:\n  def E(self,t,x): return np.zeros(3)\n  def B(self,t,x): return np.zeros(3)\ndef lorentz_force(p, v, E, B): return p.q*(E + np.cross(v,B))\n",
      "sha256": "1bef0907dc052ff3708eda47c5ff31013072225d128d3ec458c055b78932e8d5"
    },
    {
      "path": "pt-sim/pt_sim/forces/potentials.py",
      "size": 240,
      "content": "import numpy as np\ndef coulomb_potential(r,alpha=1.0): r=np.maximum(r,1e-6); return alpha/r\ndef yukawa_potential(r,g=1.0,m=1.0): r=np.maximum(r,1e-6); return (g**2)*np.exp(-m*r)/r\ndef string_potential(r,kappa=1.0,c=0.0): return kappa*r + c\n",
      "sha256": "4a285db8ddf669e82f5c15cfd31f305ead7e74f7cde603e8b5755eed2c5103f4"
    },
    {
      "path": "pt-sim/pt_sim/forces/qcd_toy.py",
      "size": 386,
      "content": "import numpy as np\ndef flux_tube_map(n=160, sep=10.0, width=1.5):\n  x=np.linspace(-sep,sep,n); y=np.linspace(-sep,sep,n); X,Y=np.meshgrid(x,y,indexing='xy')\n  tube=np.exp(-0.5*(Y/width)**2)*np.exp(-0.1*((np.abs(X)-sep/2)**2))\n  blob1=np.exp(-0.5*(((X+sep/2)**2+Y**2)/(width**2)))\n  blob2=np.exp(-0.5*(((X-sep/2)**2+Y**2)/(width**2)))\n  E=tube + 0.7*(blob1+blob2)\n  return X,Y,E/E.max()\n",
      "sha256": "aa3a1baad4fbdc45b5a30a36cb1604f1c1c76bb48e5951e6258d8043871e5739"
    },
    {
      "path": "pt-sim/pt_sim/io/hepmc.py",
      "size": 508,
      "content": "from pathlib import Path\n\ndef write_ascii_minimal(path, particles):\n    \"\"\"\n    Very small, HepMC-like ASCII for tests. 'particles' is list of dicts with keys:\n      id, px, py, pz, E, status\n    \"\"\"\n    path = Path(path); path.parent.mkdir(parents=True, exist_ok=True)\n    with open(path, \"w\") as f:\n        f.write(\"# Minimal HepMC-like ASCII (ParamTatva)\\n\")\n        for p in particles:\n            f.write(f\"P {p['id']} {p['px']} {p['py']} {p['pz']} {p['E']} {p.get('status',1)}\\n\")\n    return str(path)\n",
      "sha256": "678fb130cc9ec611d11a2b4068b1d7358e90857f88fd43ea69948b318e08b232"
    },
    {
      "path": "pt-sim/pt_sim/io/rootio.py",
      "size": 553,
      "content": "from pathlib import Path\nimport numpy as np\n\ndef write_event_npz(path, arrays: dict):\n    \"\"\"Safe default: writes numpy .npz file so tests pass without ROOT.\"\"\"\n    path = Path(path); path.parent.mkdir(parents=True, exist_ok=True)\n    np.savez_compressed(path, **arrays)\n    return str(path)\n\ndef available():\n    \"\"\"Return a tiny capability struct; extend when ROOT/uproot present.\"\"\"\n    try:\n        import uproot  # noqa: F401\n        return {\"root\": True, \"backend\": \"uproot\"}\n    except Exception:\n        return {\"root\": False, \"backend\": \"npz\"}\n",
      "sha256": "0e85594d3f4d5e0d715012edc74f9d6625eef4ba36d93d4b4d5352df35f14bbf"
    },
    {
      "path": "pt-sim/pt_sim/paramsutra.py",
      "size": 1263,
      "content": "import yaml\nfrom dataclasses import dataclass\n\n@dataclass\nclass PTGlobal:\n  alpha_prime: float = 1.0\n  intercept: float = 1.0\n\n@dataclass\nclass ElectronTarget:\n  mass_mev: float = 0.511\n  charge: int = -1\n  spin: float = 0.5\n\n@dataclass\nclass ECALGeom:\n  n: int = 32\n  cell_size_cm: float = 1.0\n  moliere_radius_cm: float = 2.0\n  depth_lambda: float = 25.0\n  sampling_fraction: float = 0.9\n  noise_sigma: float = 0.002\n\n@dataclass\nclass ShowerParams:\n  a: float = 4.0\n  b: float = 0.3\n  lateral_sigma_cm: float = 1.2\n\n@dataclass\nclass Config:\n  global_pt: PTGlobal\n  electron: ElectronTarget\n  ecal_geom: ECALGeom\n  shower: ShowerParams\n\n@dataclass\nclass Material:\n  name: str = \"PbWO4\"\n  X0_cm: float = 0.89\n  RM_cm: float = 2.0\n  Ec_MeV: float = 9.0\n  sampling_fraction: float = 0.9\n  light_yield_pe_per_GeV: float = 20000.0\n  electronics_noise_GeV: float = 0.002\n\ndef load(path: str):\n  d = yaml.safe_load(open(path, 'r'))\n  gp = PTGlobal(**d.get('global_pt', {}))\n  el = ElectronTarget(**d.get('electron', {}))\n  eg = ECALGeom(**d.get('ecal_geom', {}))\n  sp = ShowerParams(**d.get('shower', {}))\n  cfg = Config(gp, el, eg, sp)\n  # Attach optional fields\n  cfg.mode = d.get('mode', 'simplified')\n  cfg.material = Material(**d.get('material', {}))\n  return cfg\n",
      "sha256": "1b292e5715d3f1f6c9989f15824fedced01fbae3ec41344baa653cea50ee94e2"
    },
    {
      "path": "pt-sim/pt_sim/physics/accurate.py",
      "size": 1196,
      "content": "import numpy as np\ndef _gamma_profile(depth, a, b, E):\n  xs = np.linspace(0, depth.max(), 4096)\n  ys = (xs**(a-1)) * np.exp(-b*xs)\n  norm = np.trapz(ys, xs)\n  return (depth**(a-1)) * np.exp(-b*depth) * (E / norm)\ndef longitudinal_em(depth, E_GeV, X0_cm, Ec_MeV):\n  E_MeV = E_GeV * 1e3\n  a = 1.0 + 0.5 * np.log(max(E_MeV, 1.0) / max(Ec_MeV, 1.0))\n  b = 1.0\n  return _gamma_profile(depth, a, b, E_GeV)\ndef lateral_em(n, cell_size_cm, RM_cm, core_frac=0.8):\n  idx = np.arange(n) - (n-1)/2\n  X, Y = np.meshgrid(idx, idx, indexing='xy')\n  X = X * cell_size_cm; Y = Y * cell_size_cm\n  R2 = X**2 + Y**2\n  sc = 0.3 * RM_cm; st = 1.0 * RM_cm\n  Gc = np.exp(-0.5 * R2 / (sc**2))\n  Gt = np.exp(-0.5 * R2 / (st**2))\n  M = core_frac * Gc + (1.0 - core_frac) * Gt\n  return M / M.sum()\ndef digitize_energy(ecal_true, sampling_fraction, light_yield_pe_per_GeV, electronics_noise_GeV, rng):\n  mean_signal = sampling_fraction * ecal_true\n  mean_pe = mean_signal * light_yield_pe_per_GeV\n  pe = rng.normal(mean_pe, np.sqrt(np.maximum(mean_pe, 1.0)))\n  pe = np.clip(pe, 0.0, None)\n  signal = pe / light_yield_pe_per_GeV\n  return np.clip(signal + rng.normal(0.0, electronics_noise_GeV, size=ecal_true.shape), 0, None)\n",
      "sha256": "b0d039cc7061d18dec7b90d8fc4c66393a856988eb60c52239429390f7b18552"
    },
    {
      "path": "pt-sim/pt_sim/physics/simplified.py",
      "size": 484,
      "content": "import numpy as np\ndef longitudinal_profile(depth, a, b, total_energy):\n  xs = np.linspace(0, depth.max(), 2048)\n  ys = (xs**(a-1)) * np.exp(-b*xs)\n  norm = np.trapz(ys, xs)\n  return (depth**(a-1)) * np.exp(-b*depth) * (total_energy / norm)\ndef lateral_template(n, sigma_cm, cell_size_cm):\n  idx = np.arange(n) - (n-1)/2\n  X, Y = np.meshgrid(idx, idx, indexing='xy')\n  X = X * cell_size_cm; Y = Y * cell_size_cm\n  G = np.exp(-0.5 * (X**2 + Y**2) / (sigma_cm**2))\n  return G / G.sum()\n",
      "sha256": "1afc0a1a9fe55ed4f0a9599d631b750a438b187c16f43c70d974fd06248fbf7a"
    },
    {
      "path": "tests/test_boris.py",
      "size": 1159,
      "content": "import numpy as np\nfrom pt_sim.forces.boris import integrate_motion_boris\nfrom pt_sim.forces.gauge import Particle\nfrom pt_sim.forces.analytic import helix_radius, cyclotron_frequency\n\ndef uniform_zero_E(t, x): return np.array([0.0,0.0,0.0])\ndef uniform_Bz(Bz):\n    def f(t, x): return np.array([0.0,0.0,Bz])\n    return f\n\ndef test_uniformB_speed_conservation():\n    p = Particle(q=1.0, m=1.0)\n    x0 = (0.0,0.0,0.0); v0 = np.array([0.3, 0.0, 0.0])  # keep sub-relativistic\n    dt = 0.01; steps = 500\n    xs, vs = integrate_motion_boris(p, uniform_zero_E, uniform_Bz(1.0), x0, v0, dt, steps)\n    speeds = np.linalg.norm(vs, axis=1)\n    assert speeds.ptp() < 1e-3  # tiny variation\n\ndef test_uniformB_helix_radius():\n    p = Particle(q=2.0, m=1.0)\n    v0 = np.array([0.2, 0.1, 0.0])\n    Bz = 0.7\n    q_over_m = p.q/p.m\n    r_true = helix_radius(np.linalg.norm(v0[:2]), q_over_m, Bz)\n    xs, vs = integrate_motion_boris(p, uniform_zero_E, uniform_Bz(Bz), (0,0,0), v0, dt=0.01, steps=2000)\n    # Estimate radius from xy positions\n    xy = xs[:, :2]\n    rc_est = np.mean(np.linalg.norm(xy - xy.mean(axis=0), axis=1))\n    assert abs(rc_est - r_true)/r_true < 0.05\n",
      "sha256": "e1ac774b35dc1ff43d88bc61605c400bfaeb07421cdcbb5314fddd8aba2d8541"
    },
    {
      "path": "tests/test_em_shower_energy.py",
      "size": 642,
      "content": "import numpy as np\nfrom pt_sim.physics import simplified as ps\nfrom pt_sim.physics import accurate as pa\n\ndef test_energy_closure_simplified():\n    n = 32; E = 5.0\n    depth = np.linspace(0, 20.0, n)\n    longE = ps.longitudinal_profile(depth, 4.0, 0.3, E)\n    lat = ps.lateral_template(n, 1.2, 1.0)\n    e = sum(ei*lat for ei in longE)\n    assert abs(e.sum()-E)/E < 5e-3\n\ndef test_energy_closure_accurate():\n    n = 32; E = 5.0\n    depth = np.linspace(0, 20.0, n)\n    longE = pa.longitudinal_em(depth, E, X0_cm=1.0, Ec_MeV=10.0)\n    lat = pa.lateral_em(n, 1.0, RM_cm=2.0)\n    e = sum(ei*lat for ei in longE)\n    assert abs(e.sum()-E)/E < 5e-3\n",
      "sha256": "104612b09f89b1858e90a424e662a58b146ba3c3743f6fd0e7e37d0ed551f83c"
    },
    {
      "path": "tests/test_io_stubs.py",
      "size": 625,
      "content": "import numpy as np, os\nfrom pt_sim.io.rootio import write_event_npz, available\nfrom pt_sim.io.hepmc import write_ascii_minimal\n\ndef test_npz_writer(tmp_path):\n    out = tmp_path / \"event.npz\"\n    p = np.array([[1,2,3]])\n    path = write_event_npz(out, {\"p\": p})\n    assert os.path.exists(path)\n\ndef test_hepmc_ascii(tmp_path):\n    out = tmp_path / \"event.hepmc.txt\"\n    parts = [{\"id\": 11, \"px\":0.1, \"py\":0.2, \"pz\":1.0, \"E\":1.05, \"status\":1}]\n    path = write_ascii_minimal(out, parts)\n    assert os.path.exists(path)\n\ndef test_available_returns_dict():\n    info = available()\n    assert \"root\" in info and \"backend\" in info\n",
      "sha256": "816f154f3d50d9b0b6f5c32e9bce7908e649a3aecb487fab953a7894dac51973"
    }
  ]
}