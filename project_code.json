{
  "root": "/Users/prabhatsingh/param-tatva-sim",
  "generated_at_utc": "2025-09-24T02:13:18.101095Z",
  "files": [
    {
      "path": "pt-sim/pt_sim/__init__.py",
      "size": 264,
      "content": "__version__ = \"0.2.0\"\n\n# Explicit re-exports so Ruff treats them as used\nfrom . import physics as physics  # re-export\nfrom . import forces as forces    # re-export\nfrom . import io as io            # re-export\n\n__all__ = [\"physics\", \"forces\", \"io\", \"__version__\"]",
      "sha256": "d0023bf3d9d0c051645ecccba7c73a59fbfcef7e7e04d2d8f0c0a631a184b9ef"
    },
    {
      "path": "pt-sim/pt_sim/demo_forces.py",
      "size": 2804,
      "content": "from pathlib import Path\nfrom typing import Union\nimport json\nimport numpy as np\nimport matplotlib.pyplot as plt\n\nfrom .forces.gauge import Particle\nfrom .forces.em import integrate_motion, UniformField\nfrom .forces.potentials import (\n    coulomb_potential,\n    yukawa_potential,\n    string_potential,\n)\nfrom .forces.qcd_toy import flux_tube_map\n\nPathish = Union[str, Path]\n\n\ndef demo_lorentz(outdir: Pathish) -> str:\n    out = Path(outdir)\n    out.mkdir(parents=True, exist_ok=True)\n\n    e = Particle(q=-1.0, m=0.511)\n    field = UniformField(E_vec=(0.0, 0.0, 0.0), B_vec=(0.0, 0.0, 1.0))\n    xs, vs = integrate_motion(e, field, (0.0, 0.0, 0.0), (0.7, 0.0, 0.0), dt=0.05, steps=1200)\n\n    plt.figure()\n    plt.plot(xs[:, 0], xs[:, 1], lw=1.2)\n    plt.axis(\"equal\")\n    plt.xlabel(\"x\")\n    plt.ylabel(\"y\")\n    plt.title(\"Electron in Uniform B (toy NR integrator)\")\n\n    png_path = out / \"force_lorentz_spiral.png\"\n    plt.savefig(png_path, dpi=160, bbox_inches=\"tight\")\n    plt.close()\n    return str(png_path)\n\n\ndef demo_potentials(outdir: Pathish) -> str:\n    out = Path(outdir)\n    out.mkdir(parents=True, exist_ok=True)\n\n    r = np.linspace(0.05, 10.0, 1000)\n    Vc = coulomb_potential(r, 1.0)\n    Vy = yukawa_potential(r, 1.0, 0.7)\n    Vs = string_potential(r, 0.2, 0.0)\n\n    plt.figure()\n    plt.plot(r, Vc, label=\"Coulomb 1/r\")\n    plt.plot(r, Vy, label=\"Yukawa e^{-mr}/r\")\n    plt.plot(r, Vs, label=\"String κr\")\n    plt.ylim(0, 10)\n    plt.legend()\n    plt.xlabel(\"r\")\n    plt.ylabel(\"V(r)\")\n    plt.title(\"Force Potentials (toy)\")\n\n    png_path = out / \"force_potentials.png\"\n    plt.savefig(png_path, dpi=160, bbox_inches=\"tight\")\n    plt.close()\n    return str(png_path)\n\n\ndef demo_flux_tube(outdir: Pathish) -> str:\n    out = Path(outdir)\n    out.mkdir(parents=True, exist_ok=True)\n\n    X, Y, E = flux_tube_map(n=160, sep=10.0, width=1.5)\n\n    plt.figure()\n    plt.imshow(\n        E,\n        origin=\"lower\",\n        extent=[X.min(), X.max(), Y.min(), Y.max()],\n        interpolation=\"bilinear\",\n    )\n    plt.colorbar(label=\"Normalized energy density\")\n    plt.xlabel(\"x\")\n    plt.ylabel(\"y\")\n    plt.title(\"Toy Color Flux Tube (QCD-like)\")\n\n    png_path = out / \"force_flux_tube.png\"\n    plt.savefig(png_path, dpi=160, bbox_inches=\"tight\")\n    plt.close()\n    return str(png_path)\n\n\ndef run_all(outdir: Pathish) -> str:\n    out = Path(outdir)\n    out.mkdir(parents=True, exist_ok=True)\n\n    results = {\n        \"spiral_png\": demo_lorentz(out),\n        \"potentials_png\": demo_potentials(out),\n        \"flux_tube_png\": demo_flux_tube(out),\n    }\n\n    with open(out / \"demo_forces_summary.json\", \"w\") as f:\n        json.dump(results, f, indent=2)\n\n    return str(out)\n\n\nif __name__ == \"__main__\":\n    import sys\n\n    target = sys.argv[1] if len(sys.argv) > 1 else \"../out\"\n    run_all(target)\n",
      "sha256": "7c1f7d44e7a32decf05640cdc6d87c869defcf1dd9989c0ea5c5ed64782985d6"
    },
    {
      "path": "pt-sim/pt_sim/demo_run.py",
      "size": 4121,
      "content": "import json\nfrom pathlib import Path\nimport numpy as np\nfrom typing import Any, Mapping, Sequence, TypeVar, cast\nimport matplotlib.pyplot as plt\n\nfrom .physics.simplified import (\n    longitudinal_profile as simp_longitudinal_profile,\n    lateral_template as simp_lateral_template,\n)\nfrom .physics.accurate import (\n    longitudinal_em as acc_longitudinal_em,\n    lateral_em as acc_lateral_em,\n    digitize_energy as acc_digitize_energy,\n)\nfrom .paramsutra import load\n\nT = TypeVar(\"T\")\n\ndef _get(cfg: Mapping[str, Any], path: Sequence[str], default: T) -> T:\n    cur: Any = cfg\n    for k in path:\n        # Guard: if structure diverges or key missing, return default\n        if not isinstance(cur, Mapping) or k not in cur:\n            return default\n        cur = cur[k]  # type: ignore[index]\n    # We’ve walked a Mapping; cast to requested type variable for callers\n    return cast(T, cur)\n\n\ndef run(config_path: str, outdir: str) -> str:\n    \n    cfg = load(config_path)  # TypedDict[Config], still a Mapping for _get\n    out = Path(outdir)\n    out.mkdir(parents=True, exist_ok=True)\n\n    mode = str(_get(cfg, [\"mode\"], \"simplified\"))\n    E = 10.0\n\n    n = int(_get(cfg, [\"ecal_geom\", \"n_cells\"], 32))\n    depth_X0 = float(_get(cfg, [\"shower\", \"depth_X0\"], 20.0))\n    depth = np.linspace(0.0, depth_X0, n)\n\n    if mode == \"simplified\":\n        alpha = float(_get(cfg, [\"shower\", \"alpha\"], 4.0))\n        beta = float(_get(cfg, [\"shower\", \"beta\"], 0.3))\n        sigma_cm = float(_get(cfg, [\"shower\", \"lateral_sigma_cm\"], 1.2))\n        cell_cm = float(_get(cfg, [\"ecal_geom\", \"cell_size_cm\"], 1.0))\n        samp = float(_get(cfg, [\"ecal_geom\", \"sampling_fraction\"], 0.15))\n        noise = float(_get(cfg, [\"ecal_geom\", \"noise_sigma\"], 0.01))\n\n        longE = simp_longitudinal_profile(depth, alpha, beta, E)\n        lat = simp_lateral_template(n, sigma_cm, cell_cm)\n\n        e_true = np.zeros((n, n))\n        for e in longE:\n            e_true += e * lat\n\n        meas = np.clip(\n            e_true * samp + np.random.normal(0.0, noise, size=(n, n)),\n            0.0,\n            None,\n        )\n        tag = \"simplified\"\n\n    else:\n        X0_cm = float(_get(cfg, [\"material\", \"X0_cm\"], 1.0))\n        Ec_MeV = float(_get(cfg, [\"material\", \"Ec_MeV\"], 10.0))\n        RM_cm = float(_get(cfg, [\"material\", \"RM_cm\"], 2.0))\n        samp = float(_get(cfg, [\"material\", \"sampling_fraction\"], 0.15))\n        ly = float(_get(cfg, [\"material\", \"light_yield_pe_per_GeV\"], 100.0))\n        enoise = float(_get(cfg, [\"material\", \"electronics_noise_sigma\"], 0.01))\n        cell_cm = float(_get(cfg, [\"ecal_geom\", \"cell_size_cm\"], 1.0))\n\n        longE = acc_longitudinal_em(depth, E, X0_cm=X0_cm, Ec_MeV=Ec_MeV)\n        lat = acc_lateral_em(n, cell_cm, RM_cm)\n\n        e_true = np.zeros((n, n))\n        for e in longE:\n            e_true += e * lat\n\n        rng = np.random.default_rng(12345)\n        meas = acc_digitize_energy(\n            e_true,\n            samp,\n            ly,\n            enoise,\n            rng=rng,\n        )\n        tag = \"accurate\"\n\n    # Plots\n    plt.figure()\n    plt.imshow(meas, origin=\"lower\", interpolation=\"nearest\")\n    plt.colorbar(label=\"Energy (GeV)\")\n    plt.title(f\"ECAL Energy Image (electron, {tag})\")\n    plt.savefig(out / f\"ecal_image_{tag}.png\", dpi=160, bbox_inches=\"tight\")\n    plt.close()\n\n    plt.figure()\n    plt.plot(depth, longE)\n    plt.xlabel(\"Depth (X0 units)\")\n    plt.ylabel(\"Energy per layer (GeV)\")\n    plt.title(f\"Longitudinal Profile (electron, {tag})\")\n    plt.savefig(out / f\"longitudinal_profile_{tag}.png\", dpi=160, bbox_inches=\"tight\")\n    plt.close()\n\n    with open(out / f\"summary_{tag}.json\", \"w\") as f:\n        json.dump(\n            {\n                \"mode\": mode,\n                \"electron_energy_GeV\": E,\n                \"sum_measured_GeV\": float(meas.sum()),\n                \"n_cells\": int(n * n),\n                \"config_used\": str(Path(config_path).resolve()),\n            },\n            f,\n            indent=2,\n        )\n\n    return str(out)\n\n\nif __name__ == \"__main__\":\n    import sys\n\n    run(sys.argv[1], sys.argv[2] if len(sys.argv) > 2 else \"../out\")\n",
      "sha256": "e82fb46cc2b2a8f8f2171abb9b328e7dde84dcb9fb932ffca1a448118a0282cc"
    },
    {
      "path": "pt-sim/pt_sim/fastcore.py",
      "size": 753,
      "content": "\"\"\"\nFast-path wrappers. Prefer Rust (pt_core_py) if available, else Python fallback.\n\"\"\"\n\ntry:\n    import pt_core_py as _rc  # type: ignore[import-not-found]\n    HAVE_RUST = True\nexcept Exception:\n    _rc = None\n    HAVE_RUST = False\n\n\ndef kk_winding_mass2(m1, m2, w1, w2, r1, r2, alpha_prime):\n    if HAVE_RUST:\n        return float(\n            _rc.kk_winding_mass2_py(\n                int(m1),\n                int(m2),\n                int(w1),\n                int(w2),\n                float(r1),\n                float(r2),\n                float(alpha_prime),\n            )\n        )\n    # Python fallback\n    return (\n        (m1 / r1) ** 2\n        + (m2 / r2) ** 2\n        + (w1 * r1 / alpha_prime) ** 2\n        + (w2 * r2 / alpha_prime) ** 2\n    )\n",
      "sha256": "d33b731c7c34c852eda6c02543574317bd77697ec0f89bd22402c885c0483a18"
    },
    {
      "path": "pt-sim/pt_sim/forces/analytic.py",
      "size": 259,
      "content": "def helix_radius(v_perp, q_over_m, B_mag):\n    \"\"\"r = v_perp / omega,  omega = |q|B/m = |q_over_m|*B.\"\"\"\n    omega = abs(q_over_m) * abs(B_mag)\n    return abs(v_perp) / max(omega, 1e-16)\n\n\ndef cyclotron_frequency(q_over_m, B_mag):\n    return q_over_m * B_mag\n",
      "sha256": "fcbe659881c7079ca99f2bd8694418727426f4b86bcbc26adfe1f2273795eb68"
    },
    {
      "path": "pt-sim/pt_sim/forces/boris.py",
      "size": 1799,
      "content": "import numpy as np\nfrom .gauge import Particle  # noqa: F401  (used in type hints)\n\n\ndef boris_step(q_over_m, dt, v, E, B, relativistic=False, c=1.0):\n    \"\"\"\n    Single Boris push.\n    If relativistic=True, uses gamma from v at the beginning of the step.\n    Units: c can be 1.0 (natural units). Keep speeds well below c if non-relativistic.\n    \"\"\"\n    v = np.asarray(v, float)\n    E = np.asarray(E, float)\n    B = np.asarray(B, float)\n\n    if relativistic:\n        v2 = float(np.dot(v, v))\n        gamma = 1.0 / np.sqrt(max(1.0 - v2 / (c * c), 1e-12))\n    else:\n        gamma = 1.0\n\n    # Half electric kick\n    v_minus = v + (q_over_m * E) * (dt * 0.5) / gamma\n\n    # Magnetic rotation\n    t = q_over_m * B * (dt * 0.5) / gamma\n    t2 = float(np.dot(t, t))\n    v_prime = v_minus + np.cross(v_minus, t)\n    s = 2.0 * t / (1.0 + t2)\n    v_plus = v_minus + np.cross(v_prime, s)\n\n    # Half electric kick\n    v_new = v_plus + (q_over_m * E) * (dt * 0.5) / gamma\n    return v_new\n\n\ndef integrate_motion_boris(\n    p: Particle,\n    E_func,\n    B_func,\n    x0,\n    v0,\n    dt,\n    steps,\n    relativistic=False,\n    c=1.0,\n):\n    \"\"\"\n    Integrate trajectory with Boris pusher. E_func(t, x)->E, B_func(t, x)->B.\n    Returns arrays xs, vs (shape [steps, 3]).\n    \"\"\"\n    x = np.array(x0, float)\n    v = np.array(v0, float)\n    xs = np.zeros((steps, 3))\n    vs = np.zeros((steps, 3))\n\n    q_over_m = p.q / max(p.m, 1e-12)\n    t = 0.0\n\n    for i in range(steps):\n        E = np.asarray(E_func(t, x), float)\n        B = np.asarray(B_func(t, x), float)\n\n        # Boris velocity update\n        v = boris_step(q_over_m, dt, v, E, B, relativistic=relativistic, c=c)\n\n        # Position update (leapfrog consistent)\n        x = x + v * dt\n        xs[i] = x\n        vs[i] = v\n        t += dt\n\n    return xs, vs\n",
      "sha256": "367cd1587878f55017cfca7ad756f609b7cd55604763fef7bfbf307e79f7a1ea"
    },
    {
      "path": "pt-sim/pt_sim/forces/em.py",
      "size": 966,
      "content": "import numpy as np\nfrom .gauge import Field, lorentz_force\n\n\nclass UniformField(Field):\n    def __init__(self, E_vec=(0, 0, 0), B_vec=(0, 0, 1)):\n        self._E = np.array(E_vec, float)\n        self._B = np.array(B_vec, float)\n\n    def E(self, t, x):\n        return self._E\n\n    def B(self, t, x):\n        return self._B\n\n\ndef integrate_motion(particle, field, x0, v0, dt, steps):\n    x = np.array(x0, float)\n    v = np.array(v0, float)\n    xs = np.zeros((steps, 3))\n    vs = np.zeros((steps, 3))\n\n    for i in range(steps):\n        E = field.E(i * dt, x)\n        B = field.B(i * dt, x)\n        a = lorentz_force(particle, v, E, B) / max(particle.m, 1e-9)\n\n        v_half = v + 0.5 * dt * a\n        x = x + dt * v_half\n\n        E2 = field.E((i + 1) * dt, x)\n        B2 = field.B((i + 1) * dt, x)\n        a2 = lorentz_force(particle, v_half, E2, B2) / max(particle.m, 1e-9)\n\n        v = v_half + 0.5 * dt * a2\n\n        xs[i] = x\n        vs[i] = v\n\n    return xs, vs\n",
      "sha256": "d95a4fd9b6063a8271618a231da387ab9923be77b97f461eb575625309c71268"
    },
    {
      "path": "pt-sim/pt_sim/forces/gauge.py",
      "size": 406,
      "content": "from dataclasses import dataclass\nimport numpy as np\n\n\n@dataclass\nclass Particle:\n    q: float\n    m: float\n\n\nclass Field:\n    def E(self, t, x):\n        return np.zeros(3)\n\n    def B(self, t, x):\n        return np.zeros(3)\n\n\ndef lorentz_force(particle: Particle, v, E, B):\n    v = np.asarray(v, float)\n    E = np.asarray(E, float)\n    B = np.asarray(B, float)\n    return particle.q * (E + np.cross(v, B))\n",
      "sha256": "94506950e9edcefa723613608251b77060b92d899ce20d7f9e897bd824d154ea"
    },
    {
      "path": "pt-sim/pt_sim/forces/potentials.py",
      "size": 330,
      "content": "import numpy as np\n\n\ndef coulomb_potential(r, alpha: float = 1.0):\n    r = np.maximum(r, 1e-6)\n    return alpha / r\n\n\ndef yukawa_potential(r, g: float = 1.0, m: float = 1.0):\n    r = np.maximum(r, 1e-6)\n    return (g**2) * np.exp(-m * r) / r\n\n\ndef string_potential(r, kappa: float = 1.0, c: float = 0.0):\n    return kappa * r + c\n",
      "sha256": "0c92d05cefa9a23a1d80bcc34806aeab7c475a57e17aa6f17f673345ede13655"
    },
    {
      "path": "pt-sim/pt_sim/forces/qcd_toy.py",
      "size": 492,
      "content": "import numpy as np\n\n\ndef flux_tube_map(n: int = 160, sep: float = 10.0, width: float = 1.5):\n    x = np.linspace(-sep, sep, n)\n    y = np.linspace(-sep, sep, n)\n    X, Y = np.meshgrid(x, y, indexing=\"xy\")\n\n    tube = np.exp(-0.5 * (Y / width) ** 2) * np.exp(-0.1 * ((np.abs(X) - sep / 2) ** 2))\n    blob1 = np.exp(-0.5 * (((X + sep / 2) ** 2 + Y**2) / (width**2)))\n    blob2 = np.exp(-0.5 * (((X - sep / 2) ** 2 + Y**2) / (width**2)))\n\n    E = tube + 0.4 * (blob1 + blob2)\n    return X, Y, E\n",
      "sha256": "20cae966386ad605d05bb208af848b78ba9be0b23e17124b2f445ae04ed951e6"
    },
    {
      "path": "pt-sim/pt_sim/io/hepmc.py",
      "size": 543,
      "content": "from pathlib import Path\n\n\ndef write_ascii_minimal(path, particles):\n    \"\"\"\n    Very small, HepMC-like ASCII for tests. 'particles' is list of dicts with keys:\n      id, px, py, pz, E, status\n    \"\"\"\n    path = Path(path)\n    path.parent.mkdir(parents=True, exist_ok=True)\n    with open(path, \"w\") as f:\n        f.write(\"# Minimal HepMC-like ASCII (ParamTatva)\\n\")\n        for p in particles:\n            f.write(\n                f\"P {p['id']} {p['px']} {p['py']} {p['pz']} {p['E']} {p.get('status', 1)}\\n\"\n            )\n    return str(path)\n",
      "sha256": "a72ac60d8778f781433515a3c02804682a16d234b7a9114d09be8e548a21badd"
    },
    {
      "path": "pt-sim/pt_sim/io/rootio.py",
      "size": 558,
      "content": "from pathlib import Path\nimport numpy as np\n\n\ndef write_event_npz(path, arrays: dict):\n    \"\"\"Safe default: writes numpy .npz file so tests pass without ROOT.\"\"\"\n    path = Path(path)\n    path.parent.mkdir(parents=True, exist_ok=True)\n    np.savez_compressed(path, **arrays)\n    return str(path)\n\n\ndef available():\n    \"\"\"Return a tiny capability struct; extend when ROOT/uproot present.\"\"\"\n    try:\n        import uproot  # noqa: F401\n        return {\"root\": True, \"backend\": \"uproot\"}\n    except Exception:\n        return {\"root\": False, \"backend\": \"npz\"}\n",
      "sha256": "fd4d29c229da84a938ec505e317cdd82135bed10e1506d2d3a6e483268e9af42"
    },
    {
      "path": "pt-sim/pt_sim/paramsutra.py",
      "size": 863,
      "content": "from typing import TypedDict, cast\nimport yaml\n\n\nclass ShowerCfg(TypedDict, total=False):\n    alpha: float\n    beta: float\n    depth_X0: float\n    lateral_sigma_cm: float\n\n\nclass EcalGeomCfg(TypedDict, total=False):\n    n_cells: int\n    cell_size_cm: float\n    sampling_fraction: float\n    noise_sigma: float\n\n\nclass MaterialCfg(TypedDict, total=False):\n    X0_cm: float\n    Ec_MeV: float\n    RM_cm: float\n    sampling_fraction: float\n    light_yield_pe_per_GeV: float\n    electronics_noise_sigma: float\n\n\nclass Config(TypedDict, total=False):\n    mode: str\n    shower: ShowerCfg\n    ecal_geom: EcalGeomCfg\n    material: MaterialCfg\n\n\ndef load(path: str) -> Config:\n    with open(path, \"r\") as f:\n        data = yaml.safe_load(f)\n    # We accept partial configs; callers should guard with defaults.\n    return cast(Config, data if isinstance(data, dict) else {})\n",
      "sha256": "b5553cc475ff0141971d4711968bb645467e10b51552218adefeb556189992a5"
    },
    {
      "path": "pt-sim/pt_sim/physics/accurate.py",
      "size": 1862,
      "content": "import numpy as np\n\n\ndef lateral_em(n, cell_size_cm, RM_cm, core_frac: float = 0.8):\n    idx = np.arange(n) - (n - 1) / 2\n    X, Y = np.meshgrid(idx, idx, indexing=\"xy\")\n    X = X * cell_size_cm\n    Y = Y * cell_size_cm\n    R2 = X**2 + Y**2\n    sc = 0.3 * RM_cm\n    st = 1.0 * RM_cm\n    Gc = np.exp(-0.5 * R2 / (sc**2))\n    Gt = np.exp(-0.5 * R2 / (st**2))\n    M = core_frac * Gc + (1.0 - core_frac) * Gt\n    return M / M.sum()\n\n\ndef longitudinal_em(depth, E, X0_cm: float, Ec_MeV: float):\n    \"\"\"\n    Toy, PDG-inspired gamma-like longitudinal profile with energy closure.\n    depth: array in X0 units (already scaled)\n    E: GeV\n    X0_cm, Ec_MeV are accepted for future realism; not used in the toy shape.\n    \"\"\"\n    t = np.asarray(depth, float)\n    # Shape parameter grows (weakly) with E/Ec; keep >=1\n    a = float(np.log(max(E * 1e3 / max(Ec_MeV, 1e-6), 1.01)) + 1.0)\n    b = 1.0\n    f = np.power(np.maximum(t, 1e-12), a - 1.0) * np.exp(-b * t)\n    wsum = float(f.sum())\n    if wsum <= 0.0:\n        return np.ones_like(t) * (E / max(t.size, 1))\n    return E * (f / wsum)\n\n\ndef digitize_energy(\n    ecal_true,\n    sampling_fraction,\n    light_yield_pe_per_GeV,\n    electronics_noise_GeV,\n    rng,\n):\n    mean_signal = sampling_fraction * ecal_true\n    mean_pe = mean_signal * light_yield_pe_per_GeV\n    # Poisson at low mean, Gaussian approx at high mean\n    out = np.empty_like(mean_signal, dtype=float)\n    low = mean_pe < 20.0\n    high = ~low\n    out[low] = rng.poisson(mean_pe[low]).astype(float) / np.maximum(\n        light_yield_pe_per_GeV, 1e-12\n    )\n    out[high] = (\n        mean_signal[high]\n        + rng.normal(\n            0.0,\n            np.sqrt(mean_pe[high]) / np.maximum(light_yield_pe_per_GeV, 1e-12),\n        )\n    )\n    out += rng.normal(0.0, electronics_noise_GeV, size=out.shape)\n    out = np.clip(out, 0.0, None)\n    return out\n\n\n \n",
      "sha256": "a72bf70657b95fed9d015f3c8e002d1872c5456c3962c90c538e76a848a680d6"
    },
    {
      "path": "pt-sim/pt_sim/physics/simplified.py",
      "size": 858,
      "content": "import numpy as np\n\n\n\ndef lateral_template(n, sigma_cm, cell_size_cm):\n    idx = np.arange(n) - (n - 1) / 2\n    X, Y = np.meshgrid(idx, idx, indexing=\"xy\")\n    X = X * cell_size_cm\n    Y = Y * cell_size_cm\n    G = np.exp(-0.5 * (X**2 + Y**2) / (sigma_cm**2))\n    return G / G.sum()\n\n\ndef longitudinal_profile(depth, alpha, beta, E):\n    \"\"\"\n    Toy EM longitudinal profile (gamma-like).\n    depth: array in radiation-length units\n    alpha,beta: shape/scale-like toy params\n    Returns per-layer energy allocating exactly sum(...) == E.\n    \"\"\"\n    t = np.asarray(depth, float)\n    # Positive, normalized weights\n    f = np.power(np.maximum(t, 1e-12), alpha - 1.0) * np.exp(-beta * t)\n    wsum = float(f.sum())\n    if wsum <= 0.0:\n        # fallback to uniform if bad params\n        return np.ones_like(t) * (E / max(t.size, 1))\n    return E * (f / wsum)\n\n \n",
      "sha256": "36154f2549cefd64b88b8e10576d909932a68d62ddca7835f94a4a5a057ae388"
    },
    {
      "path": "tests/test_boris.py",
      "size": 1159,
      "content": "import numpy as np\nfrom pt_sim.forces.boris import integrate_motion_boris\nfrom pt_sim.forces.gauge import Particle\nfrom pt_sim.forces.analytic import helix_radius, cyclotron_frequency\n\ndef uniform_zero_E(t, x): return np.array([0.0,0.0,0.0])\ndef uniform_Bz(Bz):\n    def f(t, x): return np.array([0.0,0.0,Bz])\n    return f\n\ndef test_uniformB_speed_conservation():\n    p = Particle(q=1.0, m=1.0)\n    x0 = (0.0,0.0,0.0); v0 = np.array([0.3, 0.0, 0.0])  # keep sub-relativistic\n    dt = 0.01; steps = 500\n    xs, vs = integrate_motion_boris(p, uniform_zero_E, uniform_Bz(1.0), x0, v0, dt, steps)\n    speeds = np.linalg.norm(vs, axis=1)\n    assert speeds.ptp() < 1e-3  # tiny variation\n\ndef test_uniformB_helix_radius():\n    p = Particle(q=2.0, m=1.0)\n    v0 = np.array([0.2, 0.1, 0.0])\n    Bz = 0.7\n    q_over_m = p.q/p.m\n    r_true = helix_radius(np.linalg.norm(v0[:2]), q_over_m, Bz)\n    xs, vs = integrate_motion_boris(p, uniform_zero_E, uniform_Bz(Bz), (0,0,0), v0, dt=0.01, steps=2000)\n    # Estimate radius from xy positions\n    xy = xs[:, :2]\n    rc_est = np.mean(np.linalg.norm(xy - xy.mean(axis=0), axis=1))\n    assert abs(rc_est - r_true)/r_true < 0.05\n",
      "sha256": "e1ac774b35dc1ff43d88bc61605c400bfaeb07421cdcbb5314fddd8aba2d8541"
    },
    {
      "path": "tests/test_em_shower_energy.py",
      "size": 642,
      "content": "import numpy as np\nfrom pt_sim.physics import simplified as ps\nfrom pt_sim.physics import accurate as pa\n\ndef test_energy_closure_simplified():\n    n = 32; E = 5.0\n    depth = np.linspace(0, 20.0, n)\n    longE = ps.longitudinal_profile(depth, 4.0, 0.3, E)\n    lat = ps.lateral_template(n, 1.2, 1.0)\n    e = sum(ei*lat for ei in longE)\n    assert abs(e.sum()-E)/E < 5e-3\n\ndef test_energy_closure_accurate():\n    n = 32; E = 5.0\n    depth = np.linspace(0, 20.0, n)\n    longE = pa.longitudinal_em(depth, E, X0_cm=1.0, Ec_MeV=10.0)\n    lat = pa.lateral_em(n, 1.0, RM_cm=2.0)\n    e = sum(ei*lat for ei in longE)\n    assert abs(e.sum()-E)/E < 5e-3\n",
      "sha256": "104612b09f89b1858e90a424e662a58b146ba3c3743f6fd0e7e37d0ed551f83c"
    },
    {
      "path": "tests/test_io_stubs.py",
      "size": 625,
      "content": "import numpy as np, os\nfrom pt_sim.io.rootio import write_event_npz, available\nfrom pt_sim.io.hepmc import write_ascii_minimal\n\ndef test_npz_writer(tmp_path):\n    out = tmp_path / \"event.npz\"\n    p = np.array([[1,2,3]])\n    path = write_event_npz(out, {\"p\": p})\n    assert os.path.exists(path)\n\ndef test_hepmc_ascii(tmp_path):\n    out = tmp_path / \"event.hepmc.txt\"\n    parts = [{\"id\": 11, \"px\":0.1, \"py\":0.2, \"pz\":1.0, \"E\":1.05, \"status\":1}]\n    path = write_ascii_minimal(out, parts)\n    assert os.path.exists(path)\n\ndef test_available_returns_dict():\n    info = available()\n    assert \"root\" in info and \"backend\" in info\n",
      "sha256": "816f154f3d50d9b0b6f5c32e9bce7908e649a3aecb487fab953a7894dac51973"
    }
  ]
}